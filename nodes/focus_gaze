#!/usr/bin/env python
'''
Computes the intersection of the gaze on a reference plane (here, the sandtray)

The radius of the field of view is computed as well, and published as the 'z' coordinate
of the pose.

The gaze location is averaged over a time window to filter high frequency noise.

The result is published as a geometry_msgs::PoseStamped
'''

import rospy
import tf2_ros
import geometry_msgs.msg
from std_msgs.msg import String
import numpy as np
import math

import transformations

import collections
import time

# simple ring buffer for temporal filtering of the gaze position
gaze_buffer = collections.deque(maxlen=5)

DEFAULT_REF_FRAME = "sandtray"
DEFAULT_FACE_FRAME = "face_0"
DEFAULT_GAZE_FRAME = "gazepose_0"

SANDTRAY_WIDTH = .6
SANDTRAY_HEIGHT = .3

GAZE_POSE_TOPIC = DEFAULT_GAZE_FRAME

#####
### for correct viz, THESE VALUES NEED TO BE KEPT IN SYNC WITH THE ONE IN src/estimate_focus.cpp!

# human field of view
DEFAULT_FOV = 10. / 180 * math.pi


br = tf2_ros.TransformBroadcaster()

def _xyz_to_mat44(pos):
    return transformations.translation_matrix((pos.x, pos.y, pos.z))

def _xyzw_to_mat44(ori):
    return transformations.quaternion_matrix((ori.x, ori.y, ori.z, ori.w))

def to_mat4(trans):
    M = np.dot(_xyz_to_mat44(trans.transform.translation),
               _xyzw_to_mat44(trans.transform.rotation))
    return M


def normalize(vec):
    norm=np.linalg.norm(vec)
    if norm==0: 
        return vec
    return vec/norm

def bridge():

    rospy.init_node('gaze_sandtray_viz', anonymous=True)

    reference_frame = rospy.get_param('~reference_frame', DEFAULT_REF_FRAME)
    face_frame = rospy.get_param('~face_frame', DEFAULT_FACE_FRAME)
    gaze_frame = rospy.get_param('~gaze_frame', DEFAULT_GAZE_FRAME)
    fieldofview = rospy.get_param('~fov', DEFAULT_FOV)

    tfBuffer = tf2_ros.Buffer()
    listener = tf2_ros.TransformListener(tfBuffer)

    posepub = rospy.Publisher(GAZE_POSE_TOPIC, geometry_msgs.msg.PoseStamped, queue_size=1)
    eventpub = rospy.Publisher("sandtray/interaction_events", String, queue_size=5)

    rate = rospy.Rate(10.0)
    looking_sandtray = False
    looking_robot = False
    looking_other = False
    looking_lost = False

    while not rospy.is_shutdown():
        try:
            trans = tfBuffer.lookup_transform(reference_frame, face_frame, rospy.Time())
        except (tf2_ros.LookupException, tf2_ros.ConnectivityException, tf2_ros.ExtrapolationException) as e:
            #rospy.logwarn("Could not find a transform between %s and %s: %s" % (reference_frame,face_frame,e))
	    looking_sandtray = False
	    looking_robot = False
            looking_other = False
	    if not looking_lost:
		looking_lost = True
                eventpub.publish(String("looking_lost"))
            rate.sleep()
            continue

        # from now on, everything takes place in the REF_FRAME reference frame

        matrix = to_mat4(trans)

        gaze_origin = np.array((trans.transform.translation.x, \
                                trans.transform.translation.y, \
                                trans.transform.translation.z))

        gaze_vector = np.dot(matrix,[1,0,0,1])
        gaze_vector = (gaze_vector / gaze_vector[3])[:3] - gaze_origin
        gaze_vector = normalize(gaze_vector)

        plane_normal = normalize(np.array((0,0,1)))
        distance_plane_to_origin = 0

        t = - (np.dot(gaze_origin, plane_normal) + distance_plane_to_origin) / (np.dot(gaze_vector, plane_normal))

        gaze_projection = gaze_origin + gaze_vector * t

        gaze_buffer.append(gaze_projection[:2])

        gaze = sum(gaze_buffer)/gaze_buffer.maxlen

        pose = geometry_msgs.msg.PoseStamped()
        pose.header.stamp = rospy.Time.now()
        pose.header.frame_id = reference_frame
        pose.pose.position.x = gaze[0]
        pose.pose.position.y = gaze[1]

        # compute (an approximation of) the radius of the field of view, and publish it as the 'z' component of the pose
        distance = np.linalg.norm(gaze_origin - np.array((gaze[0], gaze[1], 0)))
        radius = math.tan(fieldofview/2) * distance

        pose.pose.position.z = radius

        posepub.publish(pose)

        # publish the corresponding TF transform as well
        t = geometry_msgs.msg.TransformStamped()

        t.header.stamp = rospy.Time.now()
        t.header.frame_id = reference_frame
        t.child_frame_id = gaze_frame
        t.transform.translation.x = gaze[0]
        t.transform.translation.y = gaze[1]
        t.transform.translation.z = 0.0
        t.transform.rotation.x = 0 
        t.transform.rotation.y = 0 
        t.transform.rotation.z = 0 
        t.transform.rotation.w = 1 

        br.sendTransform(t)

	gaze = np.array(gaze)
        if np.all(gaze > [-.1,-SANDTRAY_HEIGHT-.1]) and np.all(gaze < [SANDTRAY_WIDTH+.1,.1]):
            looking_other = False
            looking_robot = False
            looking_lost = False
            if not looking_sandtray:
                looking_sandtray = True
                eventpub.publish(String("looking_sandtray"))
        else:
            target_frames =["torso", "neck", "head"]
            for target in target_frames:
                try:
                    target_vector = tfBuffer.lookup_transform(face_frame, target, rospy.Time()).transform.translation
                    angle = math.atan2(math.sqrt(target_vector.z*target_vector.z+target_vector.y*target_vector.y),target_vector.x)
                except:
                    continue
                if angle < DEFAULT_FOV:
                    looking_other = False
                    looking_sandtray = False
                    looking_lost = False
                    if not looking_robot:
                        looking_robot = True
                        eventpub.publish(String("looking_robot"))
                    break
            else:
                looking_robot = False
                looking_sandtray = False
                looking_lost = False
                if not looking_other:
                    looking_other = True
                    eventpub.publish(String("looking_other"))


        rate.sleep()

if __name__ == '__main__':

    bridge()
