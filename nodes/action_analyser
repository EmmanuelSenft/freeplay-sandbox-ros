#!/usr/bin/env python
import numpy as np
import numpy.ma as ma
import random
import signal
import sys

import math
import rospy
import tf
from threading import Event, Lock, Timer
import actionlib
from state_analyser import StateAnalyser

from geometry_msgs.msg import PoseStamped, Point
from std_msgs.msg import String, Float32MultiArray
from visualization_msgs.msg import MarkerArray, Marker
from freeplay_sandbox_msgs.msg import ContinuousAction, DiscreteAction

MAP_HEIGHT=0.335

REFERENCE_FRAME="/sandtray"

ITEMS = ["zebra","elephant","ball","lion","giraffe","caravan","crocodile","hippo","boy","girl"]
ACTION_TYPES = ["move"]

COLORS = ["black","white","purple","blue","green","yellow","red","out"]

SPATIAL_THING = COLORS+ITEMS

class ActionAnalyser(object):
    def __init__(self):

        self._event_sub = rospy.Subscriber("events", String, self.on_event)
        self._selected_action_sub = rospy.Subscriber("sparc/selected_action",ContinuousAction , self.on_selected_action)

        self._proposed_action_sub = rospy.Subscriber("sparc/dis_action_proposed",DiscreteAction, self.on_action_proposed)
        self._selected_action_pub = rospy.Publisher("sparc/dis_action_selected", DiscreteAction, queue_size = 5)

        self._proposed_action_pub = rospy.Publisher("sparc/proposed_action", ContinuousAction, queue_size = 5)

        self._state_analyser = StateAnalyser()

    def on_action_proposed(self, message):
        print "got action"
        data = message.data
        print message.data
        print message.maskAction
        action = message.data[0]
        if action == ACTION_TYPES.index("move"):
            #Add closest
            target = self.get_target(message.data, np.array(message.maskAction))
            if target == None:
                print "error"
                return

            message_out = ContinuousAction()

            for i in range(1,len(message.data)/2):
                if message.maskAction[2*i] == True:
                    message_out.strings.append(SPATIAL_THING[message.data[2*i]]) 

            message_out.header.frame_id = ITEMS[data[1]]
            message_out.header.stamp = rospy.Time(0)
            message_out.pose.position.x = target.x
            message_out.pose.position.y = target.y
            message_out.pose.position.z = 0
            message_out.pose.orientation.x = 0
            message_out.pose.orientation.y = 0
            message_out.pose.orientation.z = 0
            message_out.pose.orientation.w = 1.
            self._proposed_action_pub.publish(message_out)

    def get_target(self, action, mask):
         masked_action = ma.array(action, mask = ~mask, dtype = int)
         return self._state_analyser.get_point_action(masked_action)

    def on_selected_action(self, message):
        item = message.header.frame_id
        zone_type, zone_index, closest = self._state_analyser.get_state_pose(item, message)
        item_id = ITEMS.index(item)

        closest[0] = SPATIAL_THING.index(closest[0])
        closest[2] = SPATIAL_THING.index(closest[2])
        closest[4] = SPATIAL_THING.index(closest[4])
        if zone_type != -1:
            zone_type = SPATIAL_THING.index(zone_type)
        goal_state = [zone_type, zone_index]+closest

        strings = message.strings+[item]
        types = []
        indexes= np.zeros(len(strings), dtype = np.int)
        for str in strings:
            splitted =  str.split("_")
            types.append(splitted[0])
            if len(splitted)>1:
                indexes[i] = int(splitted[1])

        mask = self.get_mask(strings, types, indexes)
        action_mask = np.concatenate(([True, True],  self.get_mask_item_state(goal_state, types, indexes)))

        self.publish_action(ACTION_TYPES.index("move"),item_id, goal_state, mask, action_mask)
        
    def get_mask_item_state(self, state, types, indexes):
        mask = np.zeros(len(state),dtype = bool)
        for i in range(0, len(state)/2):
            for str in types:
                print SPATIAL_THING[state[2*i]]
                print "str " + str
                if SPATIAL_THING[state[2*i]] == str:
                    print "found"
                    mask[2*i] = True
                    if str in ITEMS:
                        mask[2*i+1] = True
                    else:
                        if state[2*i+1] == indexex[j]:
                            mask[2*i+1] = True
        return mask
        
    def get_mask(self, strings, types, indexes):
        state = self._state_analyser._state
        mask = np.zeros(state.shape, dtype = bool )
           
        for i in range(0,state.shape[0]):
            if ITEMS[i] in strings:
                mask[i] = self.get_mask_item_state(state[i],types, indexes)
        return mask


    def publish_action(self, action_type, action_object, action_target, mask, action_mask):
        message = DiscreteAction() 
        message.header.frame_id = REFERENCE_FRAME
        message.header.stamp = rospy.Time(0)
        message.data.append(action_type)
        message.data.append(action_object)
        for target in action_target:
            message.data.append(target)
        for point in mask.flatten():
            message.mask.append(point)
        for point in action_mask:
            message.maskAction.append(point)
        self._selected_action_pub.publish(message)

    def run(self):
        rospy.spin()

    def on_event(self, event):
        pass

    def signal_handler(self, signal, frame):
        self._stopping = True
        sys.exit(0)
        self._state_analyser._stopping = True


if __name__ == "__main__":

    rospy.init_node('action_analyser')

    rospy.loginfo("Initializing TF...")
    analyser= ActionAnalyser()
    signal.signal(signal.SIGINT, analyser.signal_handler)
    analyser.run()
