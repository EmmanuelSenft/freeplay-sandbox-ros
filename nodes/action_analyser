#!/usr/bin/env python
import numpy as np
import numpy.ma as ma
import random
import signal
import sys

import math
import rospy
import tf
from threading import Event, Lock, Timer
import actionlib
from state_analyser import StateAnalyser

from geometry_msgs.msg import PoseStamped, Point
from std_msgs.msg import String, Float32MultiArray
from visualization_msgs.msg import MarkerArray, Marker
from freeplay_sandbox_msgs.msg import ContinuousAction, DiscreteAction

MAP_HEIGHT=0.335

DEBUG = False

REFERENCE_FRAME="/sandtray"

ITEMS = ["zebra","elephant","ball","lion","giraffe","caravan","crocodile","hippo","boy","girl"]
ACTION_TYPES = ["moveto_rocket","moveto_alternaterocket","moveto_none"]
STATIC_ITEMS = ["rocket","alternaterocket"]
LOCATIONS = STATIC_ITEMS + ["none"]
COLORS = ["black","white","purple","blue","green","yellow","red","out"]

SPATIAL_THING = COLORS+ITEMS

class ActionAnalyser(object):
    def __init__(self):

        self._event_sub = rospy.Subscriber("events", String, self.on_event)
        self._selected_action_sub = rospy.Subscriber("sparc/selected_action",ContinuousAction , self.on_selected_action)
        self._cancelled_action_sub = rospy.Subscriber("sparc/cancelled_action",ContinuousAction , self.on_cancelled_action)

        self._proposed_action_sub = rospy.Subscriber("sparc/proposed_action_dis",DiscreteAction, self.on_action_proposed)
        self._selected_action_pub = rospy.Publisher("sparc/selected_action_dis", DiscreteAction, queue_size = 5)
        self._cancelled_action_pub = rospy.Publisher("sparc/cancelled_action_dis", DiscreteAction, queue_size = 5)

        self._proposed_action_pub = rospy.Publisher("sparc/proposed_action", ContinuousAction, queue_size = 5)

        self._state_analyser = StateAnalyser()
        
        if DEBUG:
            Timer(1, self.test).start()

    def test(self):
        a = DiscreteAction()
        a.data=np.zeros(10,dtype = int)
        a.data[2]=-1
        a.data[3]=-1
        a.data[4]=SPATIAL_THING.index("giraffe")
        a.data[6]=SPATIAL_THING.index("hippo")
        a.maskAction = np.ones(10,dtype = bool)
        a.maskAction[6]=True
        a.maskAction[7]=False
        a.maskAction[2]=False
        a.maskAction[8]=False
        a.maskAction[9]=False
        self.on_action_proposed(a)

    def on_action_proposed(self, message):
        print "got action"
        data = message.data
        if DEBUG:
            print message.data
            print message.maskAction
        action = message.data[0]
        action_str = ACTION_TYPES[action]
        action_str = action_str.split("_")
        if action_str[0] == "moveto":
            goal = None
            if action_str[1] in STATIC_ITEMS:
                goal = self._state_analyser.get_pose_close_to(action_str[1])
                if goal == None:
                    print "error"
                    return
            else:
                goal = self._state_analyser.get_point_away()

            message_out = ContinuousAction()

#            for i in range(1,len(message.data)/2):
#                if message.maskAction[2*i] == True:
#                    message_out.strings.append(SPATIAL_THING[message.data[2*i]]) 

            message_out.header.frame_id = ITEMS[data[1]]
            message_out.header.stamp = rospy.Time(0)
            message_out.pose.position.x = goal[0]
            message_out.pose.position.y = goal[1]
            message_out.pose.position.z = 0
            message_out.pose.orientation.x = 0
            message_out.pose.orientation.y = 0
            message_out.pose.orientation.z = 0
            message_out.pose.orientation.w = 1.
            self._proposed_action_pub.publish(message_out)

    def get_target(self, action, mask):
         masked_action = ma.array(action, mask = ~mask, dtype = int)
         return self._state_analyser.get_point_action(masked_action)

    def on_cancelled_action(self, message):
        item = message.header.frame_id
        closest = self._state_analyser.get_state_pose(item, message)
        item_id = ITEMS.index(item)
        strings = message.strings+[item]
        mask = self.get_mask(strings)
        action_mask = [True, True]
        action = "moveto_"+LOCATIONS[closest]
        action = [ACTION_TYPES.index(action), item_id]

        self.cancel_action(action, mask)

    def on_selected_action(self, message):
        item = message.header.frame_id
        closest = self._state_analyser.get_state_pose(item, message)
        item_id = ITEMS.index(item)

        #closest[0] = SPATIAL_THING.index(closest[0])
        #closest[2] = SPATIAL_THING.index(closest[2])
        #closest[4] = SPATIAL_THING.index(closest[4])
        #if zone_type != -1:
        #    zone_type = SPATIAL_THING.index(zone_type)
        #goal_state = [zone_type, zone_index, closest]

        strings = message.strings+[item]
        #types = []
        #indexes= np.zeros(len(strings), dtype = np.int)
        #for str in strings:
        #    splitted =  str.split("_")
        #    types.append(splitted[0])
        #    if len(splitted)>1:
        #        indexes[i] = int(splitted[1])

        mask = self.get_mask(strings)
        action_mask = [True, True]
        action = "moveto_"+LOCATIONS[closest]
        action = [ACTION_TYPES.index(action), item_id]

        self.publish_action(action, mask)

        if DEBUG:
            print mask
            print action_mask

    def get_mask_item_state(self, state, types, indexes):
        mask = np.zeros(len(state),dtype = bool)
        for i in range(0, len(state)/2):
            for str in types:
                if DEBUG:
                    print SPATIAL_THING[state[2*i]]
                    print "str " + str
                if SPATIAL_THING[state[2*i]] == str:
                    mask[2*i] = True
                    if str in ITEMS:
                        mask[2*i+1] = True
                    else:
                        if state[2*i+1] == indexex[j]:
                            mask[2*i+1] = True
        return mask
        
    def get_mask(self, strings):
        state = self._state_analyser._state
        mask = np.zeros(state.shape, dtype = bool )
        if DEBUG:
            print state
        for i in range(0,len(ITEMS)):
            if ITEMS[i] in strings:
                mask[i] = True
            if LOCATIONS[state[i]] in strings:
                mask[i] = True
        #if DEBUG:
            #print mask
        return mask

    def cancel_action(self, action, mask):
        message = DiscreteAction() 
        message.header.frame_id = REFERENCE_FRAME
        message.header.stamp = rospy.Time(0)
        for point in action:
            message.data.append(point)
        for point in mask:
            message.mask.append(point)
        self._cancelled_action_pub.publish(message)


    def publish_action(self, action, mask):
        message = DiscreteAction() 
        message.header.frame_id = REFERENCE_FRAME
        message.header.stamp = rospy.Time(0)
        for point in action:
            message.data.append(point)
        for point in mask:
            message.mask.append(point)
        self._selected_action_pub.publish(message)

    def run(self):
        rospy.spin()

    def on_event(self, event):
        pass

    def signal_handler(self, signal, frame):
        self._stopping = True
        sys.exit(0)
        self._state_analyser._stopping = True


if __name__ == "__main__":

    rospy.init_node('action_analyser')

    rospy.loginfo("Initializing TF...")
    analyser= ActionAnalyser()
    signal.signal(signal.SIGINT, analyser.signal_handler)
    analyser.run()
