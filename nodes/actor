#!/usr/bin/env python
import numpy as np
import numpy.ma as ma
import math
import time, threading
import operator
import random
import json

import rospy
from freeplay_sandbox_msgs.msg import DiscreteAction, ListFloatStamped 
from std_msgs.msg import String
import signal, sys
import os

DEBUG = False
TRIGGER_NUMBER = 14

class Actor(object):
    def __init__(self):
        self._state_sub = rospy.Subscriber("sparc/state", ListFloatStamped, self.on_state)
        self._action_sub = rospy.Subscriber("sparc/rewarded_action_dis",DiscreteAction, self.on_action)
        self._event_sub = rospy.Subscriber("sparc/event", String, self.on_event)

        self._action_pub = rospy.Publisher("sparc/proposed_action_dis", DiscreteAction, queue_size = 5)
        self._actions = []
        self._trigger_states = []

        self._has_moved = False
        self._moving_Timer = threading.Timer(10, self.reset_has_moved)
        self._state = None
        self._proposed_action = None

        self._use_files = rospy.get_param('~use_file',False)
        print "using files " + str(self._use_files)
        if self._use_files:
            try:
                self.load_json()
            except Exception:
                pass

    def on_state(self, message):
        self._state = np.array(message.data)
        self.check_trigger()
        ##print self._state

    def check_trigger(self):
        if len(self._trigger_states)==0:
            return
        max_similarity = max(self.get_similarity_states(self._trigger_states,self._state[-TRIGGER_NUMBER:]))
        if max_similarity>.98:
            self.select_action()

    def on_event(self, message):
        if message.data == "select":
            self.select_action()

    def on_action(self, message):
        #print "received action"
        action = message.action_id
        reward = message.reward
        state_mask = np.array(message.state_mask,dtype = bool)
        masked_state = ma.array(self._state, mask = ~state_mask, dtype = float)
        if DEBUG:
            print "masked state"
            print masked_state

        self.add_point(action, masked_state, reward)
    
    # Similarity (euclidian distance normalised by the number of defined dimensions)
    # with x a masked array and y a vector
    def get_similarity_states(self, x, y):
        similarity = 1-np.divide(np.sum(np.square(x-y),axis=1),np.sum(~x.mask,axis=1))
        return similarity

    def select_action(self):
        #if DEBUG:
        print "selecting action"
        #print self._state
        if len(self._actions) == 0:
            return
        weighted_rewards = np.zeros(len(self._actions))
        indexes = np.zeros(len(self._actions),dtype=int)
        for i, action in enumerate(self._actions):
            #Prepare case only False, no vector
            similarity = self.get_similarity_states(action._states,self._state)
            max_similarity = max(similarity)
            idx = len(similarity) - 1 - np.argmax(similarity[::-1])
            reward = action._rewards[idx]
            weighted_rewards[i] = reward * max_similarity
            indexes[i] = idx
        if max(weighted_rewards)<=0:
            print "no good candidate"
            return
        index_selected_action = np.argmax(weighted_rewards)
        proposed_action = self._actions[index_selected_action]

        if len(self._actions[index_selected_action]._states[indexes[index_selected_action]].mask.shape) == 0:
            mask = ~np.full(self._state.shape,self._actions[index_selected_action]._states[indexes[index_selected_action]].mask, dtype=bool)
        else:
            mask = ~self._actions[index_selected_action]._states[indexes[index_selected_action]].mask

        message = DiscreteAction()
        message.header.frame_id = "sandtray"
        message.header.stamp = rospy.Time(0)
        message.action_id = self._actions[index_selected_action]._action
        message.state_mask=mask

        self._action_pub.publish(message)

    def reset_has_moved(self):
        self._has_moved = False
        self._moving_Timer = threading.Timer(10, self.reset_has_moved)

    def run(self):
        rospy.spin()

    def signal_handler(self, signal, frame):
        if self._use_files:
            self.save_json()
        sys.exit()

    def save_json(self):
        data=[]
        for a in self._actions:
            action = {"id": a._action}
            points = []
            for idx, reward in enumerate(a._rewards):
                item={"s":a._states[idx].tolist(),"r":reward}
                points.append(item)
            action["points"]=points
            data.append(action)
        with open('/home/senft/data.json','w') as outfile:
            json.dump(data, outfile)

    def load_json(self):
        with open('/home/senft/data.json','r') as infile:
            data=json.load(infile)
            for a in data:
                id = a["id"]
                points = a["points"]
                for p in points:
                    m = (p["s"] == np.array(None))
                    d = np.where(p["s"] == np.array(None),0,p["s"])
                    s=ma.array(d, mask=m)
                    self.add_point(id, s, p["r"])
                

    def add_point(self, action, state, reward):
        for known_action in self._actions:
            if known_action._action == action:
                reshaped_state=ma.reshape(state, (1,state.shape[0]))
                known_action._states=ma.append(known_action._states,reshaped_state,axis=0)
                known_action._rewards.append(reward)
                break
        else:
            new_action = Action(action, state, reward)
            self._actions.append(new_action)

class Action(object):
    def __init__(self, act, state, reward):
        self._action = act
        self._states = ma.reshape(state,(1,state.shape[0]))
        self._rewards = [reward]

if __name__ == "__main__":
    rospy.init_node('actor')
    actor = Actor()
    signal.signal(signal.SIGINT, actor.signal_handler)
    actor.run()
